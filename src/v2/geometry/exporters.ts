/**
 * Export utilities for horn geometry and data
 * Supports STL, OBJ, Hornresp, CSV, and JSON formats
 */

import * as THREE from 'three';
import { ProfilePoint } from '../profiles/types';
import { FrequencyResponse } from '../math/tlSolver';
import { PolarPattern } from '../math/protoDirectivity';

/**
 * Export geometry to STL format (ASCII)
 */
export function exportSTL(geometry: THREE.BufferGeometry, name: string = 'horn'): string {
  const positions = geometry.getAttribute('position');
  const normals = geometry.getAttribute('normal');
  const indices = geometry.getIndex();
  
  if (!positions || !indices) {
    throw new Error('Geometry must have positions and indices for STL export');
  }
  
  let stl = `solid ${name}\n`;
  
  // Process each triangle
  for (let i = 0; i < indices.count; i += 3) {
    const a = indices.array[i];
    const b = indices.array[i + 1];
    const c = indices.array[i + 2];
    
    // Get vertex positions
    const v1 = new THREE.Vector3(
      positions.array[a * 3],
      positions.array[a * 3 + 1],
      positions.array[a * 3 + 2]
    );
    
    const v2 = new THREE.Vector3(
      positions.array[b * 3],
      positions.array[b * 3 + 1],
      positions.array[b * 3 + 2]
    );
    
    const v3 = new THREE.Vector3(
      positions.array[c * 3],
      positions.array[c * 3 + 1],
      positions.array[c * 3 + 2]
    );
    
    // Calculate face normal
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    const normal = edge1.cross(edge2).normalize();
    
    // Write facet
    stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
    stl += `    outer loop\n`;
    stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
    stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
    stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
    stl += `    endloop\n`;
    stl += `  endfacet\n`;
  }
  
  stl += `endsolid ${name}\n`;
  
  return stl;
}

/**
 * Export geometry to OBJ format
 */
export function exportOBJ(geometry: THREE.BufferGeometry, name: string = 'horn'): string {
  const positions = geometry.getAttribute('position');
  const normals = geometry.getAttribute('normal');
  const uvs = geometry.getAttribute('uv');
  const indices = geometry.getIndex();
  
  if (!positions || !indices) {
    throw new Error('Geometry must have positions and indices for OBJ export');
  }
  
  let obj = `# Horn geometry: ${name}\n`;
  obj += `# Vertices: ${positions.count}\n`;
  obj += `# Faces: ${indices.count / 3}\n\n`;
  
  // Write vertices
  for (let i = 0; i < positions.count; i++) {
    const x = positions.array[i * 3];
    const y = positions.array[i * 3 + 1];
    const z = positions.array[i * 3 + 2];
    obj += `v ${x} ${y} ${z}\n`;
  }
  
  obj += '\n';
  
  // Write texture coordinates
  if (uvs) {
    for (let i = 0; i < uvs.count; i++) {
      const u = uvs.array[i * 2];
      const v = uvs.array[i * 2 + 1];
      obj += `vt ${u} ${v}\n`;
    }
    obj += '\n';
  }
  
  // Write normals
  if (normals) {
    for (let i = 0; i < normals.count; i++) {
      const nx = normals.array[i * 3];
      const ny = normals.array[i * 3 + 1];
      const nz = normals.array[i * 3 + 2];
      obj += `vn ${nx} ${ny} ${nz}\n`;
    }
    obj += '\n';
  }
  
  // Write faces (1-indexed)
  for (let i = 0; i < indices.count; i += 3) {
    const a = indices.array[i] + 1;
    const b = indices.array[i + 1] + 1;
    const c = indices.array[i + 2] + 1;
    
    if (uvs && normals) {
      obj += `f ${a}/${a}/${a} ${b}/${b}/${b} ${c}/${c}/${c}\n`;
    } else if (normals) {
      obj += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
    } else {
      obj += `f ${a} ${b} ${c}\n`;
    }
  }
  
  return obj;
}

/**
 * Export profile to Hornresp format
 */
export function exportHornresp(
  profile: ProfilePoint[],
  params: {
    name?: string;
    driverParams?: {
      Sd: number; // Driver area (cmÂ²)
      Fs: number; // Resonance frequency (Hz)
      Qes: number; // Electrical Q
      Qms: number; // Mechanical Q
      Vas: number; // Equivalent volume (liters)
    };
  } = {}
): string {
  const name = params.name || 'Horn';
  
  let hornresp = `;Hornresp input file\n`;
  hornresp += `;Generated by Horn Designer v2\n\n`;
  
  hornresp += `Seg = ${profile.length}\n`;
  hornresp += `Len = Segments\n\n`;
  
  // Driver parameters (if provided)
  if (params.driverParams) {
    const { Sd, Fs, Qes, Qms, Vas } = params.driverParams;
    hornresp += `; Driver Parameters\n`;
    hornresp += `Sd = ${Sd} cm2\n`;
    hornresp += `Fs = ${Fs} Hz\n`;
    hornresp += `Qes = ${Qes}\n`;
    hornresp += `Qms = ${Qms}\n`;
    hornresp += `Vas = ${Vas} L\n\n`;
  }
  
  // Horn segments
  hornresp += `; Horn Profile\n`;
  hornresp += `; Distance(mm)  Area(cm2)\n`;
  
  for (const point of profile) {
    const area = Math.PI * (point.r / 10) * (point.r / 10); // Convert mm to cm
    hornresp += `S${point.z.toFixed(1)} = ${area.toFixed(2)}\n`;
  }
  
  return hornresp;
}

/**
 * Export profile data to CSV
 */
export function exportProfileCSV(profile: ProfilePoint[]): string {
  let csv = 'Distance(mm),Radius(mm),Area(cm2)\n';
  
  for (const point of profile) {
    const area = Math.PI * (point.r / 10) * (point.r / 10);
    csv += `${point.z.toFixed(2)},${point.r.toFixed(2)},${area.toFixed(3)}\n`;
  }
  
  return csv;
}

/**
 * Export frequency response to CSV
 */
export function exportFrequencyResponseCSV(response: FrequencyResponse[]): string {
  let csv = 'Frequency(Hz),SPL(dB),Phase(deg),GroupDelay(ms),Re(Z),Im(Z)\n';
  
  for (const point of response) {
    const phaseDeg = (point.phase * 180) / Math.PI;
    const groupDelay = point.groupDelay || 0;
    
    csv += `${point.frequency},${point.SPL.toFixed(2)},${phaseDeg.toFixed(2)},`;
    csv += `${groupDelay.toFixed(3)},${point.Z_throat.real.toFixed(2)},${point.Z_throat.imag.toFixed(2)}\n`;
  }
  
  return csv;
}

/**
 * Export polar pattern to CSV
 */
export function exportPolarPatternCSV(pattern: PolarPattern): string {
  let csv = `Polar Pattern @ ${pattern.frequency} Hz\n\n`;
  csv += 'Angle(deg),Azimuth(dB),Elevation(dB)\n';
  
  const maxLength = Math.max(pattern.azimuth.length, pattern.elevation.length);
  
  for (let i = 0; i < maxLength; i++) {
    const angle = pattern.azimuth[i]?.angle || pattern.elevation[i]?.angle || 0;
    const azimuth = pattern.azimuth[i]?.dB || 0;
    const elevation = pattern.elevation[i]?.dB || 0;
    
    csv += `${angle},${azimuth.toFixed(2)},${elevation.toFixed(2)}\n`;
  }
  
  return csv;
}

/**
 * Export complete horn data to JSON
 */
export function exportJSON(data: {
  profile?: ProfilePoint[];
  frequencyResponse?: FrequencyResponse[];
  polarPatterns?: PolarPattern[];
  parameters?: any;
}): string {
  return JSON.stringify(data, null, 2);
}

/**
 * Create download link for exported data
 */
export function downloadFile(
  content: string,
  filename: string,
  mimeType: string = 'text/plain'
): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

/**
 * Export utilities collection
 */
export const ExportUtils = {
  /**
   * Export horn geometry in various formats
   */
  exportGeometry(
    geometry: THREE.BufferGeometry,
    format: 'stl' | 'obj',
    name: string = 'horn'
  ): void {
    let content: string;
    let filename: string;
    
    switch (format) {
      case 'stl':
        content = exportSTL(geometry, name);
        filename = `${name}.stl`;
        break;
      case 'obj':
        content = exportOBJ(geometry, name);
        filename = `${name}.obj`;
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
    
    downloadFile(content, filename);
  },
  
  /**
   * Export horn profile data
   */
  exportProfile(
    profile: ProfilePoint[],
    format: 'csv' | 'hornresp' | 'json',
    name: string = 'profile'
  ): void {
    let content: string;
    let filename: string;
    
    switch (format) {
      case 'csv':
        content = exportProfileCSV(profile);
        filename = `${name}.csv`;
        break;
      case 'hornresp':
        content = exportHornresp(profile, { name });
        filename = `${name}.txt`;
        break;
      case 'json':
        content = exportJSON({ profile });
        filename = `${name}.json`;
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
    
    downloadFile(content, filename);
  },
  
  /**
   * Export acoustic data
   */
  exportAcoustics(
    data: {
      frequencyResponse?: FrequencyResponse[];
      polarPatterns?: PolarPattern[];
    },
    format: 'csv' | 'json',
    name: string = 'acoustics'
  ): void {
    let content: string;
    let filename: string;
    
    switch (format) {
      case 'csv':
        if (data.frequencyResponse) {
          content = exportFrequencyResponseCSV(data.frequencyResponse);
          filename = `${name}_frequency.csv`;
        } else if (data.polarPatterns && data.polarPatterns.length > 0) {
          content = exportPolarPatternCSV(data.polarPatterns[0]);
          filename = `${name}_polar.csv`;
        } else {
          throw new Error('No data to export');
        }
        break;
      case 'json':
        content = exportJSON(data);
        filename = `${name}.json`;
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
    
    downloadFile(content, filename);
  }
};